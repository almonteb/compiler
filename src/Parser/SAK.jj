options
{
    STATIC = false ;
}
PARSER_BEGIN (SAK)
import java.io.StringReader;
import java.io.Reader;

public class SAK {

/**  
  A String based constructor for ease of use.
  **/
    public SAK(String s) 
    {
        this((Reader)(new StringReader(s))); 
        
    }
       
    public static void main(String args[])
    {
        try
        {
              String test = args[0];
              SAK parser = new SAK(test);
              parser.parse();
        }
        catch(Exception e)
        {
              e.printStackTrace();
        }
    }
}
PARSER_END (SAK)

SKIP :     //spaces and things to ignore                         
{
	" " | "\t" | "\r" | "\n" | "\f"
}

/* token definitions */
TOKEN :
{
        <ADD: "+">
|       <SUBTRACT: "-">
|       <DIVIDE: "/">
|       <MULTIPLY: "*">
|       <EQUALS: "=">
|	<OPERATOR: <ADD> | <SUBTRACT> | <DIVIDE> | <MULTIPLY> | <EQUALS>>
|  	<LPAREN: "(">
| 	<RPAREN: ")">
| 	<LBRACE: "{">
| 	<RBRACE: "}">
|	<STRING : (["A"-"Z", "0"-"9"])+ >
|	<CHAR : (["A"-"Z"])>
|	<INT: <DIGIT> (<DIGIT>)*>
|	<DIGIT : (["0"-"9"])>
|	<FOR : ("for")>
|	<IF : ("if")>
|	<ELSE : ("else")>
|	<PRINT : ("prt")>
|	<READINT : ("read_int")>
|	<READSTRING : ("read_str")>
| 	<IDENTIFIER: <CHAR> (<CHAR>|<DIGIT>)*>
|	<LLAMBDA : ("=>")>
| 	<MATHEXP : <INT> <OPERATOR> <INT>>

}
/*
void Type() : {} {
  <INT> | <STRING> | <CHAR> | <DIGIT>
}
void Statement():{}
{
	Type() <IDENTIFIER> <EQUALS> Expression() | <IF> Expression()<LBRACE> StatementRest() <RBRACE> | <IF> Expression() <LBRACE> StatementRest() <RBRACE> <ELSE> <LBRACE> StatementRest() <RBRACE>
	| <FOR> <IDENTIFIER> Expression() StatementRest() | Type()Expression() <IDENTIFIER> <EQUALS> <IDENTIFIER> <LLAMBDA> <LBRACE> StatementRest() <RBRACE>
	| <READINT> <IDENTIFIER> | <READSTRING> <IDENTIFIER> | <PRINT> Expression() | StatementRest()
}
void StatementRest():{}
{
	Statement() | "null"
}
*/
void Expression():{}
{
	<STRING> | <INT> | <IDENTIFIER> | <MATHEXP>
}
void Input() :
{ int count; }
{
  count=MatchedBraces() <EOF>
  { System.out.println("The levels of nesting is " + count); }
}

int MatchedBraces() :
{ int nested_count=0; }
{
  <LBRACE> [ nested_count=MatchedBraces() ] <RBRACE>
  { return ++nested_count; }
}

